# SNHU-CS320-Submission

## How can I ensure that my code, program, or software is functional and secure?

As a tester, I need to take a pessimistic approach to writing software. The old adage, "what can go wrong, will go wrong," is a valid mantra to practice. The trick is to ask oneself "What to test?" Good tests allow one to understand a system's behavior, document and verify changes introduced into the latest revision, and assert that the code meets user requirements. One of the tenets of agile methodology is to iterate and test frequently. To ensure that software is functional and secure, it is essential to write a function that should meet user requirements, and then write a corresponding test to verify it works correctly; possibly breaking the code in the process. It is also vital to understand that a failing test is a good thing; the objective should be for the test to fail, understand why it failed, and adjust the code accordingly. Constant testing assures the development team that defects are found early before they become costly game-breaking bugs and that the codebase is robust and secure from failing due to boundary or edge cases. 

## How do I interpret user needs and incorporate them into a program?

It is vital to build a software system that satisifies the goals the user seeks to accomplish. Otherwise, the software is pointless. User needs beget software features that can be divided into functional and non-functional requirements. If using agile, user stories are the basis of which requirements are extracted from. These are further refined into software specifications. Requirements eliciation is an important stage of analysis because it establishes the problems the software must be able to solve. Typically, for a more complex project, the system is modeled through UML and use case diagrams which model the interaction between actors and the software features. Once we have completed requirements elicitation, tests can be developed to verify that the software meets the end user requirements. 

## How do I approach designing software?

Before taking this class, I would use multiple print statements to ensure that I was developing a correct implementation. Requirements are divided into sub-parts that are easier to develop, and these functions or blocks of code are combined to create something greater than the sum of its parts. While breaking down a problem into smaller bits is an essential skill in software development, I now know that it is just as important to work backwards and design automated tests of the requirements to ensure that I do not miss anything, or that a solution that I think would work is the correct one. I plan to dive into books about test-driven development because it really piqued my interest, and I think it would benefit my software development process.
